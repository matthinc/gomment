#+STARTUP: indent

* Comment Struct from API
- comment_id
- thread_id
- parent_id
- created_at
- num_children (-1 means >0 children)
- children: []
** Facts
- Parents are always created before their children

* Retrieving Comments

** Newest Sibling First

*** Straightforward Soulution
- SQL query with =ORDER BY created_at LIMIT ...=
- Problem: Query result might be only leaf comments / some root comments might be missing
  - Test-Case: Insert 1 root comment with 100 child comments, query tree of 100 last comments

*** Query all root comments + 100 newest comments
- SQL query with =SELECT ... WHERE parent_id = 0 OR comment_id IN (SELECT ... ORDER BY created_at ...)=
- Problem: Possibly huge number of comments, parent comments might still be missing
  - Test-Case: Check that every comment has a parent

*** Recursive Solution
- Select newest 100 comments, then recursive SQL query that loads the parents of the parents of ...
- Problem?: Slow?, non-root comments "skip" comments between them
  - Example: Load two newest comments (9 + 8), 3 is not loaded, but the older 2 is loaded => not really a problem
    #+begin_example
   1
/  |  \
2 (3) 4
|  |  |
9 (5) 8
    #+end_example
  - Test-Case: For each parent: check if unloaded comments between oldest loaded and youngest loaded child exist
- Problem: How to calculate =num_children=
  - Soulution: Store =num_children= in SQL on insert
    #+begin_example sql
BEGIN TRANSACTION;
INSERT INTO `comment`(`thread_id`, `parent_id`, `created_at`, `author`, `email`, `text`) VALUES (1, 13, "2021-01-01 00:00:00", "foobar", "foobar@foo.bar", "you have been foood");
UPDATE `comment` SET `num_children` = `num_children` + 1 WHERE `comment_id` = 13;
COMMIT TRANSACTION;
    #+end_example
  - Test-Case: Check if =num_children= corresponds to the actual number of children
    #+begin_example sql
UPDATE `comment` AS c SET `num_children` = (SELECT COUNT(`comment_id`) FROM `comment` WHERE `parent_id` = c.`comment_id`);
    #+end_example

**** Loading more sibling comments
- Client must specify all loaded siblings => =SELECT ... WHERE parent_id = bla AND comment_id NOT IN (...)=

*** Recursive Select with limited depth and decreasing child count

#+begin_example sql
WITH RECURSIVE children(`comment_id`) AS (
	SELECT c1.`comment_id` FROM `comment` c1 WHERE c1.`thread_id` = 1 AND c1.`parent_id` IS NULL
	UNION
	SELECT c1.`comment_id` FROM `comment` c1, children WHERE c1.`parent_id` = children.`comment_id` AND c1.`depth_level` < 3
)
SELECT c1.`comment_id`, c1.`text` FROM children, `comment` c1 WHERE c1.`comment_id` = children.`comment_id`
#+end_example

**** With two CTEs for initial limit clause
#+begin_example sql
WITH anchor AS(
	SELECT c1.`comment_id` FROM `comment` c1 WHERE c1.`thread_id` = 1 AND c1.`parent_id` IS NULL ORDER BY c1.`created_at` DESC LIMIT 10
), children(`comment_id`) AS (
	SELECT anchor.`comment_id` FROM anchor
	UNION
	SELECT c1.`comment_id` FROM `comment` c1, children WHERE c1.`parent_id` = children.`comment_id` AND c1.`depth_level` < 3
)
SELECT c1.`comment_id`, c1.`text` FROM children, `comment` c1 WHERE c1.`comment_id` = children.`comment_id`
#+end_example

**** Fixed Depth Recursion
- Example Limits: 10-4-2
  - 10 + 10*4 + 10*4*2 = 130
#+begin_example sql
WITH anchor AS(
	SELECT c1.`comment_id` FROM `comment` c1 WHERE c1.`thread_id` = 1 AND c1.`parent_id` IS NULL ORDER BY c1.`created_at` DESC LIMIT 10
), lvl1 AS (
	SELECT c1.`comment_id` FROM `comment` c1, anchor WHERE c1.`parent_id` = anchor.`comment_id` ORDER BY c1.`created_at` DESC LIMIT 4
), lvl2 AS (
	SELECT c1.`comment_id` FROM `comment` c1, lvl1 WHERE c1.`parent_id` = lvl1.`comment_id` ORDER BY c1.`created_at` DESC LIMIT 2
)
SELECT * FROM `comment` WHERE `comment_id` IN (SELECT * FROM anchor UNION SELECT * FROM lvl1 UNION SELECT * FROM lvl2)
#+end_example

** Newest Branch First
- Get all ids of branch
  #+begin_example sql
WITH RECURSIVE `parents`(`parent_id`) AS (SELECT 17 UNION SELECT `comment`.`parent_id` FROM `comment`,`parents` where `comment_id` = `parents`.`parent_id`)
SELECT `parent_id` from parents;
  #+end_example
- Update all ids
  #+begin_example sql
UPDATE `comment` SET `touched_at` = c1.`created_at` FROM (SELECT `created_at` FROM `comment` WHERE `comment_id` = 17) AS c1 WHERE `comment_id` IN (
  WITH RECURSIVE `parents`(`parent_id`) AS (SELECT 17 UNION SELECT `comment`.`parent_id` FROM `comment`,`parents` where `comment_id` = `parents`.`parent_id`)
  SELECT `parent_id` from parents
);
  #+end_example
- Select faster than recursive solution: =SELECT ... ORDER BY `touched_at` DESC LIMIT ...=
- Problem: A branch (with the same `touched_at` date) is not loaded completely due to the =LIMIT= statement
  - Solution: When loading incomplete branches with the same `touched_at` date, order parents first
    - order parents first = =ORDER BY `created_at` ASC= => children get cut off => OK
    - but before that sort and limit by =ORDER BY `touched_at` DESC, `created_at` ASC LIMIT=
    - Impossible Corner case: Parent and child have the same date
  - Test: No comment without parent

*** Loading more sibling comments
- Sibling comments can be older or younger (since ordered by =touched_at=)
- => Load all comments that are older (~created_at~) than the newest loaded comment, then filter out the eixisting ones

**** Using a =NOT IN= selection
- Problem: Sqlite does not allow binding arrays by default
- =carray= extension could be used, but is not available in go: https://sqlite.org/carray.html, https://github.com/mattn/go-sqlite3/pull/347#issuecomment-259771669
#+begin_example
SELECT * FROM `comment` WHERE
  `thread_id` = 1 AND
  `parent_id` = NULL AND
  `created_at` < 1636276724 AND
  `comment_id` NOT IN (4,6)
ORDER BY `created_at` LIMIT 10
#+end_example

**** Filtering on client side
- Problem: What value to pick for the limit argument?
  - Best estimate: ~batch size + comments to exclude~
- Assumption: Ordering by ~created_at~ implies reverse ordering by ~comment_id~

*** Are there more root comments?
- Root comments do not have a common parent => no ~num_children~ available when querying

**** Artificial "Trunk" Comment without data
- No real comment (no content), could confuse other algorithms
- Comment hierarchy depth is increase by 1
- What ID to use? ~parent_id = 0~ is already used for root comments

**** Extra attributes in =thread= table
- Thread table must be queryied for every initial comment request (not expensive, cacheable)
- Possibility to store more thread-specific meta information
- Extra attributes: ~num_total~, ~num_root~
